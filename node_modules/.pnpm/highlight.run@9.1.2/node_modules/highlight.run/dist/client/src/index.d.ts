import { eventWithTime, listenerHandler } from '@rrweb/types';
import { FirstLoadListeners } from './listeners/first-load-listeners';
import { AmplitudeIntegrationOptions, ConsoleMethods, DebugOptions, MetricCategory, MixpanelIntegrationOptions, NetworkRecordingOptions, SessionShortcutOptions } from './types/client';
import { HighlightOptions, HighlightPublicInterface, Integration, Metadata, Metric, PrivacySettingOption, SamplingStrategy, SessionDetails, StartOptions } from './types/types';
import { PushPayloadMutationVariables, Sdk } from './graph/generated/operations';
import { type ViewportResizeListenerArgs } from './listeners/viewport-resize-listener';
import { GenerateSecureID } from './utils/secure-id';
import { getPreviousSessionData, SessionData } from './utils/sessionStorage/highlightSession';
import type { HighlightClientRequestWorker } from './workers/highlight-client-worker';
import { PropertyType, Source } from './workers/types';
import { Logger } from './logger';
import { HighlightFetchWindow } from './listeners/network-listener/utils/fetch-listener';
import { ConsoleMessage, ErrorMessageType } from './types/shared-types';
import { RequestResponsePair } from './listeners/network-listener/utils/models';
export declare const HighlightWarning: (context: string, msg: any) => void;
export type HighlightClassOptions = {
    organizationID: number | string;
    debug?: boolean | DebugOptions;
    backendUrl?: string;
    tracingOrigins?: boolean | (string | RegExp)[];
    disableNetworkRecording?: boolean;
    networkRecording?: boolean | NetworkRecordingOptions;
    disableBackgroundRecording?: boolean;
    disableConsoleRecording?: boolean;
    disableSessionRecording?: boolean;
    reportConsoleErrors?: boolean;
    consoleMethodsToRecord?: ConsoleMethods[];
    privacySetting?: PrivacySettingOption;
    enableSegmentIntegration?: boolean;
    enableCanvasRecording?: boolean;
    enablePerformanceRecording?: boolean;
    enablePromisePatch?: boolean;
    samplingStrategy?: SamplingStrategy;
    inlineImages?: boolean;
    inlineStylesheet?: boolean;
    recordCrossOriginIframe?: boolean;
    firstloadVersion?: string;
    environment?: 'development' | 'production' | 'staging' | string;
    appVersion?: string;
    serviceName?: string;
    sessionShortcut?: SessionShortcutOptions;
    sessionSecureID: string;
    storageMode?: 'sessionStorage' | 'localStorage';
    sendMode?: 'webworker' | 'local';
    enableOtelTracing?: HighlightOptions['enableOtelTracing'];
    otlpEndpoint?: HighlightOptions['otlpEndpoint'];
};
/**
 * Subset of HighlightClassOptions that is stored with the session. These fields are stored for debugging purposes.
 */
type HighlightClassOptionsInternal = Omit<HighlightClassOptions, 'firstloadVersion'>;
export declare class Highlight {
    options: HighlightClassOptions;
    /** Determines if the client is running on a Highlight property (e.g. frontend). */
    isRunningOnHighlight: boolean;
    /** Verbose project ID that is exposed to users. Legacy users may still be using ints. */
    organizationID: string;
    graphqlSDK: Sdk;
    events: eventWithTime[];
    sessionData: SessionData;
    ready: boolean;
    manualStopped: boolean;
    state: 'NotRecording' | 'Recording';
    logger: Logger;
    enableSegmentIntegration: boolean;
    privacySetting: PrivacySettingOption;
    enableCanvasRecording: boolean;
    enablePerformanceRecording: boolean;
    samplingStrategy: SamplingStrategy;
    inlineImages: boolean;
    inlineStylesheet: boolean;
    debugOptions: DebugOptions;
    listeners: listenerHandler[];
    firstloadVersion: string;
    environment: string;
    sessionShortcut: SessionShortcutOptions;
    /** The end-user's app version. This isn't Highlight's version. */
    appVersion: string | undefined;
    serviceName: string;
    _worker: HighlightClientRequestWorker;
    _optionsInternal: HighlightClassOptionsInternal;
    _backendUrl: string;
    _recordingStartTime: number;
    _isOnLocalHost: boolean;
    _onToggleFeedbackFormVisibility: () => void;
    _firstLoadListeners: FirstLoadListeners;
    _isCrossOriginIframe: boolean;
    _eventBytesSinceSnapshot: number;
    _lastSnapshotTime: number;
    _lastVisibilityChangeTime: number;
    pushPayloadTimerId: ReturnType<typeof setTimeout> | undefined;
    hasSessionUnloaded: boolean;
    hasPushedData: boolean;
    reloaded: boolean;
    _hasPreviouslyInitialized: boolean;
    _payloadId: number;
    _recordStop: listenerHandler | undefined;
    static create(options: HighlightClassOptions): Highlight;
    constructor(options: HighlightClassOptions, firstLoadListeners?: FirstLoadListeners);
    _reset({ forceNew }: {
        forceNew?: boolean;
    }): Promise<void>;
    _initMembers(options: HighlightClassOptions): void;
    identify(user_identifier: string, user_object?: {}, source?: Source): void;
    pushCustomError(message: string, payload?: string): void;
    consumeCustomError(error: Error, message?: string, payload?: string): void;
    consumeError(error: Error, { message, payload, source, type, }: {
        message?: string;
        payload?: object;
        source?: string;
        type?: ErrorMessageType;
    }): void;
    addProperties(properties_obj?: {}, typeArg?: PropertyType): void;
    initialize(options?: StartOptions): Promise<undefined>;
    _visibilityHandler(hidden: boolean): Promise<void>;
    _setupCrossOriginIframe(): Promise<void>;
    _setupCrossOriginIframeParent(): void;
    _setupWindowListeners(): void;
    submitViewportMetrics({ height, width, availHeight, availWidth, }: ViewportResizeListenerArgs): void;
    recordMetric(metrics: {
        name: string;
        value: number;
        category?: MetricCategory;
        group?: string;
        tags?: {
            name: string;
            value: string;
        }[];
    }[]): void;
    /**
     * Stops Highlight from recording.
     * @param manual The end user requested to stop recording.
     */
    stopRecording(manual?: boolean): void;
    getCurrentSessionTimestamp(): number;
    /**
     * Returns the current timestamp for the current session.
     */
    getCurrentSessionURLWithTimestamp(): string;
    getCurrentSessionURL(): string | null;
    snapshot(element: HTMLCanvasElement): Promise<void>;
    addSessionFeedback({ timestamp, verbatim, user_email, user_name, }: {
        verbatim: string;
        timestamp: string;
        user_name?: string;
        user_email?: string;
    }): void;
    _save(): Promise<void>;
    /**
     * This proxy should be used instead of rrweb's native addCustomEvent.
     * The proxy makes sure recording has started before emitting a custom event.
     */
    addCustomEvent<T>(tag: string, payload: T): void;
    _sendPayload({ sendFn, }: {
        sendFn?: (payload: PushPayloadMutationVariables) => Promise<number>;
    }): Promise<void>;
    private takeFullSnapshot;
}
declare global {
    interface Console {
        defaultLog: any;
        defaultError: any;
        defaultWarn: any;
        defaultDebug: any;
    }
}
export { FirstLoadListeners, GenerateSecureID, MetricCategory, getPreviousSessionData, };
export type { AmplitudeIntegrationOptions, ConsoleMessage, MixpanelIntegrationOptions, Integration, Metadata, Metric, HighlightFetchWindow, HighlightOptions, HighlightPublicInterface, RequestResponsePair, SessionDetails, };
