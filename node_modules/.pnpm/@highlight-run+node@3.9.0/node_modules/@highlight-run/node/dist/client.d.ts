/// <reference types="node" />
import { BufferConfig, ReadableSpan, Span } from '@opentelemetry/sdk-trace-base';
import { BatchSpanProcessorBase } from '@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase';
import { Attributes, Context, Span as OtelSpan, SpanOptions } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';
import type { IncomingHttpHeaders } from 'http';
import type { HighlightContext, NodeOptions } from './types.js';
type TraceMapValue = {
    attributes: {
        'highlight.session_id': string;
        'highlight.trace_id': string;
    };
    destroy: () => void;
};
declare class CustomSpanProcessor extends BatchSpanProcessorBase<BufferConfig> {
    private _listeners;
    private traceAttributesMap;
    private finishedSpanNames;
    getTraceMetadata(span: ReadableSpan): TraceMapValue | undefined;
    setTraceMetadata(span: OtelSpan, attributes: TraceMapValue['attributes']): Map<string, TraceMapValue> | undefined;
    getFinishedSpanNames(): Set<string>;
    clearFinishedSpanNames(): void;
    onEnd(span: ReadableSpan): void;
    onShutdown(): void;
    forceFlush(): Promise<void>;
    registerListener(listener: () => void): () => boolean;
}
export declare class Highlight {
    readonly FLUSH_TIMEOUT_MS: number;
    _projectID: string;
    _debug: boolean;
    otel: NodeSDK;
    private tracer;
    private processor;
    constructor(options: NodeOptions);
    get activeSpanProcessor(): CustomSpanProcessor;
    get finishedSpans(): Span[];
    stop(): Promise<void>;
    _log(...data: any[]): void;
    recordMetric(secureSessionId: string, name: string, value: number, requestId?: string, tags?: {
        name: string;
        value: string;
    }[]): void;
    log(date: Date, msg: string, level: string, stack: object, secureSessionId?: string, requestId?: string, metadata?: Attributes): void;
    consumeCustomError(error: Error, secureSessionId: string | undefined, requestId: string | undefined, metadata?: Attributes, options?: {
        span: OtelSpan;
    }): void;
    flush(): Promise<void>;
    waitForFlush(expectedSpanNames?: string[]): Promise<string[]>;
    setAttributes(attributes: Attributes): void;
    parseHeaders(headers: Headers | IncomingHttpHeaders): HighlightContext;
    runWithHeaders<T>(headers: Headers | IncomingHttpHeaders, cb: (span: OtelSpan) => T | Promise<T>): Promise<T>;
    startWithHeaders<T>(spanName: string, headers: Headers | IncomingHttpHeaders, options?: SpanOptions): {
        span: OtelSpan;
        ctx: Context;
    };
    startActiveSpan(name: string, options?: SpanOptions): Promise<OtelSpan>;
}
export {};
//# sourceMappingURL=client.d.ts.map